# SQLD

( [https://3rdscholar.tistory.com/category/데이터 사이언스/SQL](https://3rdscholar.tistory.com/category/%EB%8D%B0%EC%9D%B4%ED%84%B0%20%EC%82%AC%EC%9D%B4%EC%96%B8%EC%8A%A4/SQL) 에서 구문, 결과 참고 )

# 과목I 데이터 모델링의 이해

## 제1장 데이터 모델링의 이해

- **데이터 모델의 이해**
    - 모델링: 복잡한 현실 세계를 추상화, 단순화, 명확화(정확화)하기 위해 일정한 표기법으로 표현하는 기법
    
    [모델링의 특징]
    
    | 추상화 | 현실세계를 일정한 형식에 맞추어 표현. 표기법 따름 |
    | --- | --- |
    | 단순화 | 복잡한 현실세계를 쉽게 이해할 수 있도록 약속한 규약을 준수하는 표기법으로 표현 |
    | 명확화 | 여러 관계자가 이해하기 쉽게 애매모호함을 제거하고 정확하게 현상을 기술 |
    
    [모델링의 세 가지 관점]
    
    | 데이터 관점 | 업무가 어떤 데이터와 관련 있는지, 데이터 간 관계는 무엇인지 모델링(Data, What) |
    | --- | --- |
    | 프로세스 관점 | 업무가 무엇인지, 무엇을 해야 하는지 모델링 (Process, How) |
    | 상관 관점 | 업무 처리 방법에 따라 데이터가 어떻게 영향 받고 있는 지 모델링 (Data vs. Process, Interaction) |
    - 데이터 모델의 기능: 가시화, 명세화, 구조화된 틀 제공, 문서화, 다양한 관점 제공, 상세 수준의 표현 방법 제공
    
    [데이터 모델링의 중요성]
    
    | 파급효과 (Leverage) | 데이터 구조 변경에 따른 영향 (비용) 大 |
    | --- | --- |
    | 간결한 표현 (Conciseness) | 정보 요구 사항과 한계를 정확하고 간결하게 표현해야 |
    | 데이터 품질 (Data Quality) | - 오래된 데이터의 활용 가지 ↑, 품질이 안 좋으면 비즈니스의 기회 상실로 연결될 가능성 有
    - 중복 데이터 미정의, 비즈니스 정의 불충분, 동일한 성격의 데이터 분리로 데이터 불일치 등 |
    
    [데이터 모델링 유의할 점]
    
    - 중복: 여러 장소에 같은 정보 저장하지 않도록
    - 비유연성: 데이터 혹은 프로세스의 작은 변화가 중대한 변화 일으킬 가능성 적게. 데이터 정의를 데이터 사용 프로세스와 분리해서 유연성 높여야.
    - 비일관성: 다른 데이터와 모순되지 않도록
    
    [데이터 모델링의 3단계 진행]   
    
    | 개념적 데이터 모델링
    (현실→개념적구조) | - 추상화 수준 높음
    - 업무 중심적이고 포괄적
    - 전사적 데이터 모델링 시 많이 사용
    - 핵심 엔터티와 그들 간 관계 발견, ERD 생성 |
    | --- | --- |
    | 논리적 데이터 모델링
    (개념→논리적구조) | - 누가(Who), 어떻게(How) 데이터에 엑세스 할 것인지 기록
    - 기본키, 속성, 관계, 외래키 등 정확하게 표현하는 단계
    - 정규화
    - 일관성 확보하고 중복 제거하여 신뢰성 있는 데이터 구조 얻는 데 목적 |
    | 물리적 데이터 모델링
    (논리→물리구조(DB)) | - 컴퓨터에 어떻게 저장할 지, 성능/저장공간 등 고려 |
    
    [데이터 독립성]
    
    - 목적: 유지보수 비용 절감, 데이터 복잡도 ↓, 중복된 데이터 ↓, 요구사항 대응 ↑
    - 효과: 각 view 독립성 유지, 단계별 스키마에 따라 DDL과 DML 다름
    
    | 외부단계 | 외부스키마 1 | 외부스키마 2 | 외부스키마 3 | - 사용자 관점에 따라 스키마 구성 |
    | --- | --- | --- | --- | --- |
    |  |  | 논리적 데이터 독립성
    (외부적/개념적 사상) |  | - 개념 스키마 변경되어도 외부 스키마에 영향 X
    - 논리적 구조 변경되어도 응용 프로그램에 영향 X |
    | 개념적 단계 |  | 개념 스키마 |  | - 모든 사용자 관점 통합 |
    |  |  | 물리적 데이터 독립성
    (물리적 사상) |  | - 내부 스키마가 변경되어도 외부/개념 스키마는 영향 X
    - 저장장치 구조변경은 응용프로그램과 개념 스키마에 영향  X |
    | 내부적 단계 |  | 내부 스키마 |  | - 물리적 저장구조 |
    
    [ERD: 데이터 모델의 표기법]
    
    Entity Relationship Diagram: 엔터티 간 관계 이해하기 쉽게 다이어그램으로 표시하는 방법
    
    **<작업순서>**
    
    1. 엔터티를 그린다
    2. 엔터티를 적절하게 **배치**한다: 가장 중요한 엔터티 왼쪽 상단에, 업무 흐름의 중심인 엔터티 중앙에
    3. 엔터티 간 식별자 **관계를 설정**한다
    4. **관계명**을 기술한다 (verb)
    5. 관계의 **참여도**를 기술한다: 관계차수(하나의 관계 (IE: 실선, Barker: 실선/점선 혼합), 다수 참여의 관계 (까마귀발))
    6. 관계의 **필수여부**를 기술한다: 관계선에 원 표현
    
    [좋은 데이터 모델의 요소]
    
    | 완전성 | 업무에 필요로 하는 모든 데이터 정의 |
    | --- | --- |
    | 중복 배제 | 동일한 사실은 반드시 한 번만 기록 |
    | 업무 규칙 | - 업무 규칙 데이터 모델에 표현하고 해당 데이터 모델 활용하는 모든 사용자가 공유할 수 있도록 제공
    - 모델 분석만으로도 비즈니스 로직이 이해되어야 |
    | 데이터 재사용 | - 통합 모델이어야만 데이터 재사용성 높일 수 있음
    - 데이터가 애플리케이션에 대해 독립적으로 설계되어야
    - 외부의 업무 환경 변화에 유연하게 대응해야
    - 데이터를 합리적으로 균형있되 단순하게 분류해야
    ⇒ 데이터 통합성과 독립성 고려해서 재사용이 가능해야 함 |
    | 의사소통 | 많은 업무 규칙들이 엔터티, 서브타입, 속성, 관계 등의 형태로 최대한 자세하게 표현되어야
    ⇒ 모델을 보고 이해 당사자들끼리 의사소통이 이루어질 수 있어야 함 |
    | 통합성 | 데이터 구조: 동일한 데이터는 조직 전체에서 한 번만 정의되고 이를 여러 다른 영역에서 참조/활용 |

데이터 모델링의 세 가지 요소

- 업무가 관여하는 어떤 것 (Thing): **Entity (엔터티)**
    - 업무에 필요하고 유용한 정보를 저장하고 관리하기 위한 집합적인 것
        - *사람, 사물, 사건, 개념 등의 명사에 해당*
    - 업무 활동상 지속적인 관심을 가지고 있어야 하는 대상, 비즈니스 구현 위해 저장해야 하는 것을 의미
    - 인스턴스: 엔터티의 하나의 값 (과목 (엔터티) - 국어, 수학, 영어 (인스턴스))
    - 엔터티 중 눈에 보이지 않는 개념도 존재
    
    [특징]
    
    | 업무에서 필요로 하는 정보 |  |
    | --- | --- |
    | 식별 가능해야 | 각 인스턴스를 구분하기 위한 유일한 식별자가 존재해야 함 |
    | 인스턴스의 집합 | 두 개 이상 |
    | 업무 프로세스에 의해 이용돼야 |  |
    | 속성 포함 | 반드시 속성을 가지고 있어야 함 |
    | 관계의 존재 | 다른 엔터티와 최소 한 개 이상의 관계 존재해야
    - 단, 통계성 엔터티, 코드성 엔터티, 시스템 처리시 내부 필요에 의한 엔터티 제외 |
    
    [분류]
    
    | 유무형에 따라 | 유형엔터티 | 물리적인 형태 존재 |
    | --- | --- | --- |
    |  | 개념엔터티 | 물리적인 형태 X, 개념적 정보 |
    |  | 사건엔터티 | 업무를 수행함에 따라 발생 |
    | 발생시점에 따라 | 기본엔터티
    (=키 엔터티) | - 원래 존재하는 정보
    - 독립적으로 생성, 타 엔터티의 부모 역할
    - 고유한 주식별자 가짐 |
    |  | 중심엔터티 | - 기본엔터티로부터 발생
    - 업무에서 중심적 역할
    - 데이터 양 많이 발생
    - 다른 엔터티와의 관계 통해 많은 행위엔터티 생성 |
    |  | 행위엔터티 | - 두 개 이상의 부모엔터티로부터 발생
    - 자주 내용 바뀌거나 데이터 양 증가 |
    | 스스로 생성 여부 | 독립엔터티 |  |
    |  | 의존엔터티 |  |
- 어떤 것이 가지는 성격: **Attributes (속성)**
    - 업무에서 필요로 하는 인스턴스로 관리하고자 하는 의미상 더이상 분리할 수 없는 최소의 데이터 단위
    - 엔터티에 대한 설명이자 인스턴스의 구성요소 (인스턴스의 성격 구체적으로 나타냄)
        - 한 개의 엔터티는 두 개 이상의 인스턴스의 집합
        - 한 개의 엔터티는 두 개 이상의 속성 가짐
        - 한 개의 속성은 한 개의 속성값 가짐
    - 표기법: [“#” 식별자/ “*” 필수/ “o” 선택값] 이란 의미
    
    [특징]
    
    - 해당 업무에서 필요하고 관리하고자 하는 정보여야
    - 정규화 이론에 근거하여 정해진 주식별자에 함수적 종속성 가져야
    - 하나의 속성=하나의 값. 다중값일 경우 별도의 엔터티 이용해서 분리
    
    [분류]
    
    | 속성 특성에 따라 | 기본속성 | - 업무로부터 추출한 속성 |
    | --- | --- | --- |
    |  | 설계속성 | - 업무를 규칙화하기 위해 새로 만든 속성
    - 일련번호와 같이 unique한 식별자 부여하기 위해 새로 정의하는 속성 |
    |  | 파생속성 | - 다른 속성에 영향 받아 발생 (계산값, 변형값) |
    | 엔터티 구성방식에 따라 | PK(Primary Key) | 엔터티에서 단 하나의 인스턴스 식별할 수 있는 속성 |
    |  | FK(Foreign Key) | 다른 엔터티와의 관계에서 포함된 속성 |
    |  | 일반속성 | PK, FK 외 |
    | 세부 의미 쪼갤 수 있는 지에 따라 | 단순형 | (나이, 성별) |
    |  | 복합형 | (주소 (=시, 구, 동 번지)) |
    
    단일값 속성: 속성 하나에 한 개 값 (주민번호)
    
    다중값 속성: 속성 하나에 여러 개 값 (전화번호 (=집 번호, 핸드폰 번호, 등)) ⇒ 1차 정규화 대상
    
    - 도메인: 각 속성이 가질 수 있는 값의 범위
- 어떤 것 간의 관계: **Relationships (관계)**
    - 엔터티의 인스턴스 사이의 논리적인 연관성으로서 존재의 형태로서나 행위로서 서로에게 연관성이 부여된 상태 =  **상호연관성이 있는 상태**
    - 페어링(Pairing): 엔터티 내 인스턴스가 개별적으로 관계를 갖는 것
    - 관계 정의 체크사항
        - 두 개의 엔터티 사이 관심 있는 연관규칙 존재하는가?
        - 두 개의 엔터티 사이 정보의 조합 발생하는가?
        - 업무기술서, 장표에 관계연결에 대한 규칙이 서술되어 있는가?
        - 업무기술서, 장표에 관계연결을 가능하게 하는 동사가 있는가?
    
    [분류]
    
    | 존재에 의한 관계 | 어떠한 이벤트에 의해 발생되는 관계가 아닌 |
    | --- | --- |
    | 행위에 의한 관계 | 행위에 의해 발생 |
    
    [표기법]
    
    | 관계명 | - 엔터티가 관계에 참여하는 형태
    - 애매한 동사 피하고 현재형으로 표현 |
    | --- | --- |
    | 관계차수 | - 참여자의 수 표현 (다수의 경우 까마귀 발 사용)
    1) 1:1 관계
    2) 1:M 관계
    3) M:M 관계 |
    | 관계선택사양 | 필수참여) 
    - 참여하는 모든 참여자가 반드시 관계를 가짐 (타 엔터티의 참여자와 연결되어야 함)
    - IE, Barker: 실선으로 표기
    선택참여) 
    - Barker표기법: ERD에서 원으로 표현
    
    양쪽 엔터티에 모두 선택참여가 표시되었다면 0:0의 관계. 검토 필요. |

-

- **식별자 (Identifier)**
    - 인스턴스 구별해 낼 수 있는 논리적인 이름 (엔터티 내에서 하나의 행 집어낼 때 사용)
    - 하나의 엔터티는 반드시 하나의 유일한 식별자가 존재해야
    - 업무에서 자주 이용되는 속성을 주식별자로, 이름으로 기술되는 것들은 가능하면 주식별자로 지정하지 않게, 주식별자가 복합일 경우 과도한 복합 배제
    
    [주식별자 특징]
    
    | 유일성 | 엔터티 내에 모든 인스턴스들을 유일하게 구분 |
    | --- | --- |
    | 최소성 | 주식별자를 구성하는 속성의 수는 유일성을 만족하는 최소의 수  |
    | 불변성 | 한 번 특정 엔터티에 지정되면 그 식별자의 값은 변하지 않아야 함 |
    | 존재성 | 주식별자가 지정되면 반드시 데이터 값이 존재해야 (Not Null) |
    
    [분류]
    
    | 대표성 여부 | 주식별자 | - 엔터티 내에서 각 행 구분 가능
    - 참조관계 연결 가능 |
    | --- | --- | --- |
    |  | 보조식별자 | - 엔터티 내에서 각 행 구분 가능
    - 참조관계 연결 불가 |
    | 스스로 생성 여부 | 내부식별자 | 엔터티 내부에서 스스로 생성 |
    |  | 외부식별자 | 타 엔터티에서 받아옴 (FK 역할) |
    | 속성 수 | 단일식별자 | 하나의 속성으로 구성된 식별자 |
    |  | 복합식별자 | 두 개 이상의 속성으로 구성 |
    | 대체 여부 | 본질식별자 | 업무에 의해 생성 |
    |  | 인조식별자 | 인위적으로 생성
    - 불필요한 인덱스 발생시킬 수 있음
    - 본질적인 데이터 중복 차단 X
    - 식별자의 수 많아졌을 경우 고려 |
    
    [식별자관계와 비식별자관계에 따른 식별자]
    
    업무 특징, 자식엔터티의 주식별자 구성, SQL작성 전략에 의해 결정됨
    
    |  | 식별자관계 | 비식별자관계 |
    | --- | --- | --- |
    |  | - 자식의 주식별자로 부모의 주식별자 상속 (반드시 부모엔터티가 생성되어야 자기 자신의 엔터티 생성 가능) | - 부모엔터티로부터 속성 받았지만 일반적인 속성으로만 사용 |
    |  | - 식별자 관계로만 설정할 경우 주식별자 속성이 지속적으로 증가할 수 밖에 없는 구조가 되어 개발 복잡성과 오류 유발 가능성 | - 비식별자 관계로만 설정할 경우 불필요한 다량의 조인 유발되면서 성능 저하 가능성 |
    | 목적 | 강한 연결관계 표현 | 약한 연결관계 표현 |
    | 표기법 | 실선 | 점선 |
    | 연결 고려사항 | - 반드시 부모엔터티 종속
    - 자식 주식별자 구성에 부모 주식별자 포함
    - 상속받은 주식별자속성 타 엔터티로 이전 필요한 경우 | - 약한 종속관계
    - 자식 주식별자 구성을 독립적으로 구성할 경우
    - 상속받은 주식별자 속성을 타 엔터티에 이전하지 않도록 차단 필요한 경우
    - 부모쪽의 관계참여가 선택관계 (부모 엔터티의 주식별자가 null이 허용되는 경우) |
    
    ⇒ 비식별자 관계 설정 고려해야 할 때: 관계분석 → 약한 관계이거나  자식테이블 독립 PK 필요, PK 속성 단순화 필요한 경우
    

## 제2장 데이터 모델과 SQL

- **성능 데이터 모델링**: DB 성능 향상 목적으로 성능과 관련된 사항들이 데이터 모델링 작업에 반영될 수 있도록 하는 것
    
    [고려사항 (순서)]
    
    - 데이터 모델링 시 정규화 작업 수행
    - 데이터베이스 용량 산정, 발생되는 트랜잭션 유형 파악
    - 용량 및 트랜잭션 유형에 따라 반정규화 수행
    - 이력 데이터 모델의 조정, PK/FK 조정, 슈퍼/서브 타입 변환 조정 등 수행
    - 성능 관점에서 데이터 모델 검증
- **정규화 (Normalization)와 반정규화**
    
    주요 관심사별로 데이터 분산시키는 효과, 유연성 극대화
    
    함수적 종속을 가지고 있는 일반 속성에 입력/수정/삭제 이상현상 제거
    
    중복 속성 제거, 한 테이블의 데이터 용량 최소화
    
    **⇒ 정규화된 테이블에 대해 입력/수정/삭제에 대해 성능 향상, 조회성능은 향상/저하 가능**
    
    | 유형 | 1차 정규화 | 2차 정규화 | 3차 정규화 |
    | --- | --- | --- | --- |
    | 설명 | - 모든 속성은 반드시 하나의 값을 가져야 한다
    - 같은 유형의 속성이 여러 개인 경우 해당 속성 분리
    (속성의 원자성 확보) | - 엔터티의 일반속성은 주식별자 전체에 종속적이어야 한다
    - 완전 종속되지 않은 속성 분리
    
    ** 함수정 종속성
    결정자 → 종속자
    (결정자가 종속자를 함수적으로 결정) | 엔터티의 일반속성 간에는 서로 종속적이지 않는다 (이행적 종속 배제)
    - 일반 속성끼리 함수 종속 발생한 경우 속성 분리 |
    |  |  | PK에 종속적이지 않거나 PK 중 일부 칼럼들에만 종속적인 칼럼은 분리되어야 함 |  |
    | 효과 | 과도한 인덱스 생성 방지, 조회 분산 | 조인 발생하지만 유일 인덱스 스캔 하기 때문에 성능상 문제 발생할 가능성 ↓ |  |
    
    보이스-코드 정규화: 결정자 안에 함수 종속을 가진 주식별자 속성을 분리
    
    4차 정규화, 5차 정규화까지 존재
    
    [정규화와 성능]
    
    - 전에 없었던 조인이 발생하게 되더라도 효율적인 인덱스 사용을 통해 조인 연산 수행하면 성능상 단점은 거의 없음
    - 적은 용량의 테이블 생성 → 조인 연산 시 적은 용량의 테이블 먼저 읽어 조인 수행 = 성능상 유리
    - 정규화 하면 하나의 인덱스만 만들어도 됨
    
    **[반정규화]**
    
    - 성능을 위해 데이터 중복을 허용하는 것 (조인 연산 회피)
    - 조회 성능은 향상될 수 있으나 입력, 수정, 삭제 성능은 보장 X
    - 반정규화를 통한 모델 성능 향상/저하 둘 다 가능
    - 데이터 불일치로 인한 정합성 문제, 불필요한 트랜잭션으로 인한 성능 문제 발생 가능
    - 기본적으로 정규화 고려하고 반정규화 꼭 필요한 대상인지 검증하고, 다른 방법 없는지 검토한 후 적용
        
        
        | 반정규화 대상 조사 | 다른 방법 유도 검토 | 반정규화 적용 |
        | --- | --- | --- |
        | - 범위 처리 빈도수 조사
        - 대량의 범위 처리 조사
        - 통계성 프로세스 조사
        - 테이블 조인 개수 | - 뷰 테이블
        - 클러스터링
        - 인덱스 조정
        - 응용 애플리케이션 변경 | - 테이블 반정규화
        - 속성의 반정규화
        - 관계의 반정규화 |
    - 기법
    
    | 테이블 반정규화 | 1:1 관계 테이블 병합 | - 1:1 관계 통합하여 성능 향상
    - 2개의 테이블 하나의 테이블로 병합하여 조인 연산 제거 |
    | --- | --- | --- |
    |  | 1:M 관계 테이블 병합 | - 1:M 관계 통합
    - 2개 테이블 하나로 병합하여 조인 제거 |
    |  | 슈퍼/서브 타입 테이블 병합 | - 슈퍼/서브 관계 통합하여 성능 향상
    - 슈퍼/서브 타입 관계 하나의 테이블로 병합하여 조인 제거
    
    (아래 ‘데이터베이스 구조와 성능’ 참고) |
    |  | 수직 분할 | - 칼럼 단위 테이블을 1:1로 분리
    - 트랜잭션 처리되는 유형 파악 선행되어야 (자주 조회되는 칼럼 파악) |
    |  | 수평 분할
    (파티셔닝, Partitioning) | - 로우 단위 집중 발생 트랜잭션 분석을 통한 성능 향상
    - 테이블의 저장 건수가 매우 많을 때 로우 단위로 테이블 쪼갬
    
    > 범위 파티셔닝 (기간별, 보관 주기에 따라 쉽게 삭제 가능)
    > 리스트 파티셔닝 (특정 값에 따라)
    > 해시 파티셔닝 (지정된 hash 조건에 따라 해싱 알고리즘 적용하여 테이블 분리): 사용자는 특정 데이터가 어디 파티션에 들어갈 지 예측할 수 없음 |
    |  | 중복 테이블 추가 | - 다른 업무 or 서버가 다른 경우 동일한 테이블 구조 중복하여 원격 조인 제거 |
    |  | 통계 테이블 추가 | - sum, avg 등 미리 계산해둠으로써 조회 시 성능 향상 |
    |  | 이력 테이블 추가 | - 마스터 테이블에 존재하는 레코드 중복하여 이력 테이블에 저장 |
    |  | 부분 테이블 추가 | - 특정 테이블에서 자주 조회하는 칼럼들이 있을 때 해당 칼럼들을 모아놓은 별도의 반정규화된 테이블 생성 |
    | 칼럼 반정규화 | 중복 칼럼 추가 | - 조인으로 인한 성능 저하 예방 위해 중복 칼럼 추가하여 조인 제거 |
    |  | 파생 칼럼 추가 | - 미리 값 계산하여 칼럼에 보관 (연산 제거) |
    |  | 이력 테이블 칼럼 추가 | - 대량의 이력 데이터 처리할 때 불특정한 날 조회나 최근 값 조회할 때 나타날 수 있는 성능 저하 예방 위해 이력 테이블에 칼럼 추가 (최근값여부, 시작일자, 종료일자 등) |
    |  | PK에 의한 칼럼 추가 | - 복합의미 갖는 PK 단일 속성일 때 칼럼 분리 - 일반 칼럼으로 도출 |
    |  | 응용 시스템의 오작동을 위한 칼럼 추가 | - 데이터 처리하다가 잘못 처리하여 원래의 값으로 복구를 원하는 경우 이전 데이터를 임시적으로 중복하여 보관하는 기법 |
    | 관계 반정규화 | 중복 관계 추가 | - 여러 경로에 걸쳐서 조인하는 경우 조인 연산 줄이는 방법
    (A-B-C 조인을 A-C 조인으로) 
    ⇒ 관계의 반정규화는 데이터 무결성을 꺠뜨릴 위험 갖지 않고서도 데이터 처리의 성능 향상 가능 |
    
- **대량 데이터에 따른 성능**
    - 수평/수직 분할 통해 성능 저하 예방 가능
        - 절차: 모델링 완성 → 각 테이블 용량 산정 → 트랜잭션 처리 패턴 분석 → 분리 검토
    
    [성능 저하 현상]
    
    | 로우 체이닝
    (Row Chaining) | - 로우 길이가 너무 길어서 2개 이상의 블록에 걸쳐 하나의 로우가 저장된 형태
    - 성능저하 발생 가능 ->트랜잭션이 접근하는 칼럼 유형을 분석하여 1:1로 테이블 분리하면 디스크 I/O가 줄어들어 조회 성능 향상 가능 |
    | --- | --- |
    | 로우 마이그레이션
    (Row Migration) | - 데이터 블록세어 수정 발생하면 해당 데이터 블록에 수정된 데이터를 저장하지 못하고 다른 블록의 빈 공간을 찾아 저장하는 방식
    - 마이그레이션 일어나면서 하나의 행 읽을 때 2개 이상의 데이터 블록 읽게 되는 현상 발생 |
- **데이터베이스 구조와 성능**
    
    [슈퍼/서브 타입 모델]
    
    - 업무를 구성하는 데이터의 특징을 분석하여 공통점과 차이점을 고려하여 효과적으로 표현 가능
    - 공통 부분을 슈퍼 타입 엔터티로 도출하고 공통으로부터 상속 받아 다른 엔터티와 차이가 있는 속성에 대해서는 별도의 서브 타입 엔터티로 구분하는 방식
    - 논리 데이터 모델링 시 정의한 슈퍼/서브 타입 모델은 물리 데이터 모델로 변환 시 슈퍼 타입 기준, 서브 타입 기준, 개별 타입 기준으로 변환될 수 있음
        
        
        | 슈퍼 타입
        (Single 타입, All in one 타입) 기준 | - 슈퍼/서브 타입 모델 전체를 하나의 테이블로 변환
        - 트랜잭션 시 전체를 일괄적으로 처리하는 경우 선택
        - 확장성 나쁨, 관리 용이성 좋음, I/O 성능 나쁨, 조인 성능 좋음 |
        | --- | --- |
        | 서브 타입
        (Plus 타입, Super+Sub 타입) 기준 | - 서브 타입 테이블들로 변환
        - 도출된 각각의 서브 타입에는 변환 전 슈퍼 엔터티에 있던 칼럼들을 공통적으로 가지고 있음
        - 트랜잭션 시 각 서브 타입을 기준으로 처리하는 경우 선택 |
        | 개별 타입
        (OneToOne 타입, 1:1 타입) 기준 | - 슈퍼 타입과 서브 타입의 각각 개별테이블로 변환
        - 슈퍼 테이블, 서브 테이블 모두 생성
        - 트랜잭션 시 각 슈퍼, 서브 타입을 기준으로 처리하는 경우 선택
        - 확장성 좋음, 관리 용이성 좋지 않음, I/O 성능 좋음, 조인 성능 나쁨 |
    - 변환의 중요성
        - 트랜잭션 슈퍼 타입 기준으로 처리하는 게 유리할 때 테이블은 개별 타입으로 유지되면 UNION 연산에 의해 성능 저하 가능
        - 트랜잭션 서브 타입 기준으로 처리하는 게 유리할 때 슈퍼 타입으로 되어 있는 경우 성능 저하 가능성
        - 트랜잭션 개별 타입 기준으로 처리하는 게 유리할 때 테이블이 슈퍼 타입으로 되어 있어서 불필요하게 많은 양의 데이터 집약되어 성능 저하 가능
    
    [PK 칼럼 순서와 성능]
    
    - 복합PK인 경우 트랜잭션 조회 패턴에 따라 PK칼럼 순서 조정해야 효율적
        - 인덱스 구성 칼럼 중 맨 앞에 위치하는 칼럼이 가능한 한 조건절에서 “=” 조건으로 들어오게
    
    [외래키(FK) 칼럼에 대한 인덱스 생성의 중요성]
    
    - 논리적이든 물리적이든 FK 제약조건 있다면 외래키 칼럼에 대해 인덱스 생성하는 것이 성능상 유리한 경우가 많음
- **분산 데이터베이스와 성능**
    - **분산 데이터베이스**: 여러 곳으로 분산되어 있는 데이터베이스를 하나의 가상 시스템으로 사용할 수 있도록 한 데이터베이스
        - 논리적으로는 동일한 시스템이지만 컴퓨터 네트워크를 통해 물리적으로 분산되어 있음
    - 분산 데이터베이스의 **투명성**: 해당 DB 사용하는 사용자가 DB가 분산되어 있는 것을 인식하지 못하게
        
        
        | 분할 투명성
        (단편화) | 하나의 논리적 Relation(테이블)이 여러 단편으로 분할되어 각 단편의 사본이 여러 site에 저장되지만 사용자는 한 곳에 위치하는 것으로 인식해야 함 |
        | --- | --- |
        |  투명성 | 사용하려는 데이터의 저장 장소 명시할 필요 없음 |
        |  사상 투명성 | 지역 DBMS와 물리적 DB 사이 매핑 보장
        - 데이터가 어디에 위치하는지에 대해 신경 쓸 필요 X |
        | 중복 투명성 | DB 객체가 여러 site에 중복되어 있다는 것을 알 필요 X |
        | 장애 투명성 | transaction의 원자성 유지. 분산 DB의 장애상황과 무관하게 원자성 유지 |
        | 병행 투명성 | 다수 transaction 동시에 수행 시 결과의 일관성 유지 |
    - 적용기법
        
        
        | 테이블 위치(Location) 분산 | 테이블의 위치를 각각 다른 DB에 위치 |
        | --- | --- |
        | 테이블 분할(Fragmentation) 분산 | 수직/수평 분할 통해 각 테이블 쪼개어 분산 |
        | 테이블 복제(Replication) 분산 | 동일한 테이블을 다른 지역이나 서버에서 동시에 생성하여 관리
        > 부분복제: 통합된 테이블(본사)에서 각 지사별로 지사에 해당되는 로우 가지고 있는 형태
        > 광역복제: 통합된 테이블(본사)에서 각 지사에도 동일한 데이터 모두 가지고 있는 형태 |
        | 테이블 요약(Summarization) 분산 | 지역 간 또는 서버 간 데이터가 비슷하지만 서로 다른 유형으로 존재하는 경우
        > 분석요약: 각 지사별로 존재하는 요약정보 본사에 통합하여 다시 전체에 대해서 요약정보 산출
        > 통합요약: 각 지사별로 존재하는 다른 내용의 정보를 본사에 통합하여 다시 전체에 대해 요약정보 산출 |
        
        [분산 DB 설계 고려해야 하는 경우]
        
        - 성능 중요한 사이트, 실시간 동기화 요구되지 않는 경우, 백업 사이트 구성하는 경우
        - 공통코드, 기준정보, 마스터 데이터의 성능향상
        - 특정 서버에 부하가 집중되어 부하 분산해야 하는 경우
        - Global Single Instance(GSI): 통합된 한 개의 인스턴스 (=통합 데이터베이스 구조를 의미함)
            - = 분산 데이터베이스와 대치되는 개념
- **Null 속성**
    1. **Null 값의 연산은 언제나 Null**
        1. Null ≠ 공백
        2. Null ≠ 0
        3. Null 값으로 가능한 연산은 오직 IS NUll, IS NOT NULL 뿐
    2. **집계함수는 Null 값 제외하고 처리**
        1. SUM(주문금액)/COUNT(*)  ≠  AVG(주문금액)

# 과목 II SQL 기본 및 활용

## 제1장 SQL 기본

- **관계형 데이터베이스 개요**
    - 관계형 데이터베이스는 정규화를 통한 합리적인 테이블 모델링을 통해
        - 이상현상 제거, 데이터 중복 피하고 많은 사용자가 동시에 데이터 공유 및 조작할 수 있는 기능 제공
        - 데이터 표준화 통한 데이터 품질 확보
    - SQL문장 종류
        
        
        | DML (Manipulation) | SELECT
        INSERT, UPDATE, DELETE |
        | --- | --- |
        | DDL (Definition) | CREATE, ALTER, DROP, RENAME |
        | DCL (Control) | GRANT, REVOKE |
        | TCL (Transaction Control) | COMMIT, ROLLBACK |
    - **테이블**: 관계형 데이터베이스의 기본 단위. 반드시 하나 이상의 칼럼을 가짐
    - 데이터 유형 (Oracle 기준)
        
        
        | CHAR | - 고정 길이 문자열
        - 할당된 변수 값의 길이가 주어진 길이보다 작을 경우에는 차이 길이만큼 공백으로 채워짐 |
        | --- | --- |
        | VARCHAR2 | - 가변 길이 문자열. 할당된 변수값의 바이트만 적용
        - 끝에 공백 다르면 다른 문자로 판단 (공백도 문자로 취급)
        - SQL Server는 VARCHAR로 표현 |
        | NUMBER | - NUMBER(전체 자리 수, 소수 자리 수) |
        | DATE | - 날짜와 시각 정보 |
        
- **DDL**
    
    물리적 DB 객체 구조 정의
    
    CREATE TABLE, ALTER TABLE, RENAME TABLE, DROP TABLE, TRUNCATE TABLE
    
    | CREATE TABLE
    
    생성된 테이블구조 
    DESC 테이블명;
    으로 확인 가능 | CREATE TABLE | CREATE TABLE 테이블명
    (칼럼명1 DATATYPE [DEFAULT],
    칼럼명2 DATATYPE [DEFAULT]);
    
    데이터 유형 뒤에 제약조건 달거나 (칼럼 LEVEL 정의 방식) 
    칼럼 지정 후에
    -CONSTRAINT 제약조건명 PRIMARY KEY (칼럼명)
    -CONSTRAINT 제약조건명 FOREIGN KEY (칼럼) REFERENCES 참조하는 테이블명 (참조하는 칼럼)
    (테이블 LEVEL 정의 방식) | - 테이블명은 가능한 단수형, 다른 테이블명과 중복되지 않게
    - 한 테이블 내에서는 칼럼명 중복 X
    - 칼럼 데이터 유형은 꼭 지정
    - 테이블명과 칼럼명은 반드시 문자로 시작, 길이에 대한 한계 有
    - a-z, A-Z, 0-9, _, $, #만 허용
    - 테이블 생성시 대/소문자 구분 X. 기본적으로 대문자로 만들어짐
    - DATETIME 유형은 크기 지정 X
    - 문자 유형은 최대 길이 표시 |
    | --- | --- | --- | --- |
    |  | 제약조건 | 데이터 무결성 유지하기 위해 테이블의 특정 칼럼에 설정하는 제약. 테이블 생성할 때 반드시 기술할 필요는 없지만 이후에 추가/수정하려면 쉽지 않음 | [종류]
    PRIMARY KEY (기본키)
    - 하나의 테이블에 하나의 PK
    - UNIQUE & NOT NULL
    - 인덱스 자동 생성
    UNIQUE (고유키)
    - NULL 가능
    FOREIGN KEY (외래키)
    - 참조 무결성 제약 옵션 선택
    NOT NULL
    CHECK
    - 입력할 수 있는 값의 범위, 종류 제한
    - TRUE or FALSE 평가할 수 있는 논리식 지정 |
    |  | SELECT 문장으로 테이블 생성
    (CTAS 구문) | CREATE TABLE 테이블명 AS
    SELECT *
    FROM 테이블; | - 칼럼별로 데이터 유형 다시 정의하지 않아도 됨
    - 기존 테이블의 제약조건 중 NOT NULL 제약만 적용되고 나머지 제약조건은 없어짐 |
    | ALTER TABLE
    (칼럼, 제약조건
    추가/수정/제거할 때) | ADD COLUMN | ALTER TABLE 테이블명
    ADD (추가 칼럼명 데이터유형 [디폴트] [NOT NULL]); | 새롭게 추가된 칼럼은 테이블의 마지막 칼럼 (위치 지정 불가) |
    |  | DROP COLUMN | ALTER TABLE 테이블명
    DROP (삭제할 칼럼명); | - 한 번에 하나의 칼럼만 삭제 가능
    - 칼럼 삭제 후 테이블 내에 최소 하나 이상의 칼럼 존재해야
    - 한 번 삭제된 칼럼은 복구 불가능 |
    |  | RENAME COLUMN | ALTER TABLE 테이블명 RENAME 기존 칼럼명 TO 새로운 칼럼명; |  |
    |  | ADD CONSTRAINT | ALTER TABLE 테이블명 ADD CONSTRAINT 제약조건명 제약조건 (칼럼명);
    or
    ALTER TABLE 테이블명 ADD CONSTRAINT 제약조건명 FOREIGN KEY (칼럼명) REFERENCES 참조하는 테이블명 (참조하는 칼럼명) |  |
    |  | DROP CONSTRAINT | ALTER TABLE 테이블명 DROP CONSTRAINT 제약조건명; |  |
    |  | MODIFY COLUMN | ALTER TABLE 테이블명
    MODIFY (칼럼명 데이터유형 [기본값] [NOT NULL]); | - 데이터 유형, 디폴트 값, NOT NULL 제약조건에 대한 변경
    - 데이터 존재한다면 칼럼 크기 줄이는 데 한계 존재 (NULL만 있거나 테이블에 아무 행도 없으면 가능)
    - NULL만 있으면 데이터 유형 변경 가능
    - DEFAULT값 바꾸면 변경 작업 이후 발생한느 행 삽입에만 영향
    - NULL값 없을 경우에만 NOT NULL 제약조건 추가 가능 |
    | RENAME TABLE |  | RENAME 기존 테이블명 TO 새로운 테이블명; |  |
    | DROP TABLE |  | DROP TABLE 테이블명 [CASCADE CONSTRAINT]; | - 모든 데이터 및 구조 삭제
    - CASCADE CONSTRAINT 옵션 입력하면 해당 테이블과 관계가 있었던 참조되는 제약조건에 대해서도 삭제 (SQL Server 에는 존재하지 않음) |
    | TRUNCATE TABLE |  | TRUNCATE TABLE 테이블명; | - 모든 행 제거하고 저장 공간 재사용 가능하도록 해제 (구조는 살아있음)
    - AUTO COMMIT (DDL)
    - 전체 데이터 삭제하는 경우 시스템 활용 측면에서 DELETE TABLE보다 나음. 단, 정상적인 복구 불가능함. 주의 |
- **DML**
    
    데이터 변경
    
    - 변경 사항 영구적으로 저장하기 위해서는 COMMIT 명령 수행 해 TRANSACTION 종료해야
        
        (SQL Server는 DML도 AUTO COMMIT 방식으로 처리)
        
    
    | INSERT | INSERT INTO 테이블명 [(칼럼명….)] VALUES (값…) | - INTO 절의 칼럼명과 VALUES 절의 값을 서로 1:1로 매핑
    - 칼럼명 명시할 경우, 테이블의 칼럼 순서와 매치할 필요X. 정의하지 않은 칼럼은 Default로 NULL 값 입력 (PK나 Not NULL로 지정된 칼럼은 NULL허용 안됨)
    - 칼럼명 명시하지 않을 경우, 테이블의 칼럼 순서대로 데이터가 빠짐없이 입력되어야 (NULL값의 경우 ‘’나 NULL로 기입) |
    | --- | --- | --- |
    | UPDATE | UPDATE 테이블명 SET 칼럼명=새로운 칼럼 값 [WHERE 수정 대상 행 식별조건]; | - WHERE 절 사용하지 않는다면 테이블 전체 데이터 수정 |
    | DELETE | DELETE [FROM] 테이블명
    [WHERE 삭제 대상 식별조건]; | - WHERE 절 사용하지 않으면 테이블 전체 데이터 삭제
    > 전체 데이터 삭제하는 경우 TRUNCATE TABLE 권고
       (단 TRUNCATE TABLE은 ROLLBACK이 불가능하므로 주의) |
    | MERGE | MERGE 
    INTO 타겟 테이블명
    USING 소스 테이블명
    ON 조인 조건식
    WHEN MATCHED THEN
    UPDATE… SET…
    WHEN NOT MATCHED THEN
    INSERT…VALUES…; | - 새로운 행 입력 혹은 수정하는 작업 한 번에 가능 |
- **TCL**
    - ALL OR NOTHING의 개념
    - 데이터베이스 응용 프로그램은 트랜잭션의 집합
    - TCL의 대상: DML
    
    **트랜잭션:** 데이터베이스의 논리적 연산 단위, 하나의 업무 단위로 묶여서 처리되어야 함  (원자성)
    
    - 원자성 충족하기 위해 DB는 다양한 레벨의 잠금 기능 제공
        - 잠금(LOCK): 트랜잭션 수행하는 동안 특정 데이터에 대해 다른 트랜잭션이 동시에 접근하지 못하도록 제한하는 기법. 잠금 걸린 데이터는 잠금 실행한 트랜잭션만 독점적으로 접근 가능하고 잠금 수행한 트랜잭션에 의해서만 해제 가능.
    
    [트랜잭션의 특징]
    
    | 원자성 (Atomicity) | all or nothing. 모두 성공적으로 실행하던지 전혀 실행되지 않은 상태로 남아야 |
    | --- | --- |
    | 일관성 (Consistency) | 트랜잭션 전 잘못된 내용이 없다면 트랜잭션 후에도 잘못된 내용이 있으면 안됨 |
    | 고립성 (Isolation) | 트랜잭션 수행 중 다른 트랜잭션의 영향을 받아 잘못된 결과 만들어선 안됨 |
    | 지속성 (Durablilty) | 트랜잭션 성공적으로 수행되면 갱신된 내용은 영구적으로 저장 |
    
    [종류]
    
    COMMIT과 ROLLBACK의 효과: 데이터 무결성 보장, 영구적인 변경 이전에 변경 사항 확인 가능, 논리적으로 연관된 작업 그룹핑하여 처리 가능
    
    | COMMIT | COMMIT; | - 변경사항 DB에 반영. 이전 데이터 영원히 없어짐
    - SQL Server는 기본적으로 AUTO COMMIT 모드 |
    | --- | --- | --- |
    | ROLLBACK | ROLLBACK; | - 변경 사항 취소. 이전 데이터 재저장 |
    | SAVEPOINT | SAVEPOINT SP1;
    ROLLBACK TO SP1; | - 현 지점에서 SP1까지만 롤백
    - 복수의 저장점 정의 가능. 동일이름으로 여러 개 저장점 정의했을 때는 마지막 정의한 저장점만 유효 |
    
    [COMMIT, ROLLBACK 없이도 트랜잭션 자동으로 종료되는 경우]
    
    - DDL 문장 실행하면 AUTO COMMIT (DML 문장 이후 명시적 커밋 없이도 DDL 문장 실행되면 데이터 변경 사항이 자동으로 커밋)
    - DB를 정상적으로 접속 종료할 시 자동으로 COMMIT
    - 애플리케이션의 이상 종료로 DB와의 접속 단절됐을 때 자동으로 ROLLBACK
    

구문 순서: SELECT, FROM, WHERE, GROUP BY, HAVING, ORDER BY

실행 순서: FROM → WHERE → GROUP BY → HAVING → SELECT → ORDER BY

- **SELECT 문**
    
    조회 기능. DML
    
    `SELECT [ALL/DISTINCT] 칼럼명,…` < = 모든 칼럼 정보 보고 싶을 경우에는 ‘*; 사용
    
    `FROM 테이블명;`
    
    - 숫자 데이터만 우측 정렬
    - 칼럼 레이블 생성 가능. 별명에 공백, 특수문자 포함하거나 대소문자 구분 필요한 경우에만 double quotation 사용
    
    [산술 연산자]
    
    - NUMBER와 DATE 자료형에 적용. 우선순위 위한 괄호 적용 ( (), *, / +, - 순).
    
    [합성 연산자]
    
    - Oracled은 || , SQL Server는 +, CONCAT(string1, string2)는 둘 다 가능
    - 합성 연산 결과에 의해 새로운 칼럼 생성
- **WHERE 절**
    - 조인 조건, 결과 제한하기 위한 조건
    
    [연산자] (우선순위: 괄호, 비교연산자/SQL연산자, 부정 연산자(NOT), AND, OR)
    
    | 유형 | 연산자 | 비고 |
    | --- | --- | --- |
    | 비교 연산자 | =, >, <, >=, <= |  |
    | SQL 연산자 | BETWEEN a AND b | a, b 값 포함 |
    |  | IN (list) |  |
    |  | LIKE ‘비교문자열’ | (%, _ 사용) |
    |  | IS NULL | “칼럼명 = NULL” 불가 |
    | 논리 연산자 | AND, OR, NOT | () → NOT → AND → OR 순위 |
    | 부정 비교 연산자 | != , ^=, <>
    NOT 칼럼명 =
    NOT 컬럼명 > |  |
    | 부정 SQL 연산자 | NOT BETWEEN a AND b |  |
    |  | NOT IN (list) |  |
    |  | IS NOT NULL |  |
- (내장) **함수 (Function)**
    
    
    | 단일행 함수
    - SELECT, WHERE, ORDER BY 절에 사용 가능
    - 단 하나의 결과 리턴
    - 함수의 중첩 가능 | 문자형 | lower, upper, ascii, chr/char, concat, substr/substring, length/len, ltrim, rtrim, trim
    
    initcap, instr(위치 반환), lpad, rpad, replace, translate |
    | --- | --- | --- |
    |  | 숫자형 | abs, sign, mod, ceil/ceiling, floor, round, trunc, sin, cos, tan, exp, power, sqrt, log, ln |
    |  | 날짜형
    (날짜를 숫자로 저장하기 때문에 산술연산자로도 계산 가능) | sysdate/getdate, extract/datepart, to_number(to_char(d,’YYYY’|’MM’|’DD’))/YEAR|MONTH|DAY
    
    1: 하루
    1/24: 1시간
    1/24/60: 1분
    1/24/60/60: 1초 |
    |  | (명시적) 형변환 | to_number: 문자 → 숫자
    to_char: 숫자, 날짜 → 문자
    to_date: 문자 → 날짜
    
    SQL Server: cast, convert |
    |  | NULL 관련
    - 공집합(조건에 맞는 데이터가 한 건도 없는 경우) ≠ NULL
    - 집계함수와 스칼라 서브쿼리 같은 경우 결과값이 공집합인 경우에도 NULL 출력 | - nvl/isnull (공집합을 다른 값으로 변화시키진 않음)
    - nullif
    > 두 문자열 다르면 첫 번째 문자열 출력, 같다면 NULL 출력
    - coalesce |
    |  | CASE 표현 (if-then-else와 유사):
    SELECT에 사용
    CASE [칼럼] WHEN 조건 THEN 결과
    [ELSE 디폴트값]
    END [AS 칼럼명] 
    - 중첩해서 사용 가능 | - 특정 값에 대해서 조건에 따라 각기 다른 값 리턴하도록
    - DECODE 함수와 같은 기능
    > DECODE (칼럼, 조건1, 값1, 조건2, 값2, 디폴트) |
    | 다중행 함수
    - 입력값 여러 개, 출력은 한 개
    - 입력값으로 전체 건수  NULL인 경우만 함수 결과가 NULL. 일부만 NULL인 경우 다중행 함수의 대상에서 제외 | 집계 함수
    (Aggregate Fxn) | count, sum, avg, max, min 등 |
    |  | 그룹 함수
    (Group Fxn) | rollup, cube, grouping sets |
    |  | 윈도우 함수
    (Window Fxn) | - 그룹 내 순위(rank) 관련: rank, dense_rank, row_number
    - 그룹 내 집계 관련: sum, max, min, avg, count
    - 그룹 내 행 순서 관련: first_value, last_value, lag, lead
    - 그룹 내 비율 관련: cume_dist, percent_rank, ntile, ratio_to_report |
    
- **GROUP BY, HAVING 절**
    
    [집계함수 (Aggregate Function)]
    
    - *여러 행들의 그룹이 모여 그룹당 단 하나의 결과 돌려주는 함수*
    - **SELECT, HAVING, ORDER BY절에 사용** 가능 (WHERE절에는 올 수 없음!)
    - 일반적으로 GROUP BY 절과 사용되지만 테이블 전체가 하나의 그룹이 되는 경우에는 GROUP BY 절 없이 단독으로 사용 가능
        
        
        | COUNT(*) | NULL값 포함한 행 수 출력 |
        | --- | --- |
        | COUNT(표현식) | NULL 값인 행 제외 출력 |
        | SUM | NULL 제외 |
        | AVG | NULL 제외 |
        | MAX | NULL 제외
        - 공집합을 MAX 함수로 감싸면 NULL 나옴 |
        | MIN | NULL 제외 |
        | STDDEV | NULL 제외 표준편차 |
        | VARIANCE | NULL 제외 분산 |
    
    [GROUP BY절, HAVING절]
    
    - 행들 소그룹화. 소그룹별 기준 정한 후 SELECT절에 집계함수 사용
    - 집계함수의 통계 정보는 NULL값 가진 행 제외하고 수행
    - ALIAS명 사용할 수 없음!
    - **WHERE 절**: 전체 데이터를 GROUP으로 나누기 전에 행들 미리 제거 (따라서 집계함수는 WHERE절에 올 수 없음)
        
        **HAVING 절**: GROUP BY절에 의해 만들어진 소그룹의 집계데이터에 제한 조건을 두어 조건 만족하는 내용만 표시 (=결과집합의 행에 조건 적용). SELECT 절에 사용되지 않은 칼럼이나 집계함수 아니더라도 조건절로 사용 가능
        
        ⇒ WHERE절에서 조건절을 적용해 GROUP BY의 계산 대상 줄이는 것이 효율적
        
        ⇒ WHERE절의 조건 변경은 데이터 값이 변경될 수 있지만 HAVING 절의 조건 변경은 결과 데이터 변경은 없고 출력되는 레코드 개수만 변경될 수 있음
        
    - GROUP BY절에 그룹 단위 표시해 주어야 SELECT절에서 그룹 단위의 칼럼과 집계함수 사용 가능
    
    [CASE 표현을 활용한 월별 데이터 집계]
    
    - CASE() ~ GROUP BY 기능은 제1정규화로 인해 반복되는 칼럼의 경우(ex. 월) 구분 칼럼을 두고 여러 개의 레코드로 만들어진 집합을 정해진 칼럼 수만큼 확장해 집계 보고서 만드는 유용한 기법
    
    [집계함수와 NULL 처리]
    
    다중행 함수는 입력 값으로 전체 건수가 NULL값인 경우만 함수의 결과가 NULL
    
    일부만 NULL인 경우는 NULL인 행을 다중 행 함수의 대상에서 제외
    
    따라서 다중 행 함수에 NVL 함수 사용할 필요 X.
    
- **ORDER BY 절**
    - 특정 칼럼 기준으로 정렬/출력하는 데 사용. SQL 문장의 제일 마지막에 위치
    - 칼럼명 대신 ALIAS명, 칼럼 순서 나타내는 정수 사용 가능 (혼용 가능)
    - Default: ASC (오름차순)
    - Oracle은 NULL값을 가장 큰 값으로 취급. SQL Server는 반대
    - SELECT 절에 존재하지 않는 칼럼 사용해도 문제 없음
        - 하지만 SELECT문에 GROUP BY절 사용한 경우 ORDER BY 절에 기재하는 칼럼이 SELECT절에 존재하는 칼럼이나 표현식이어야함.
            - GROUP BY 사용한다면 개별 데이터는 저장하지 않기 때문에 GROUP BY 이후에 수행되는 SELECT나 ORDER BY절에서 개별 데이터 사용하는 경우 에러 발생
            
            | ERROR | 정상 수행 |
            | --- | --- |
            | SELECT JOB
            FROM EMP
            GROUP BY JOB
            HAVING COUNT(*) > 0
            ORDER BY SAL; | SELECT JOB
            FROM EMP
            GROUP BY JOB
            HAVING COUNT(*) >0
            ORDER BY MAX(EMPNO), MAX(MGR), SUM(SAL): |
- **조인 (WHERE절에 조인 조건** (+일반 검색 조건) **기술)**
    - 두 개 이상의 테이블 연결해 데이터 출력하는 것. FROM 절에 여러 테이블 나열되더라도 단 두 개의 집합 간에만 조인 일어남 (차례대로 조인 수행)
    - JOIN 필요한 이유: 불필요한 데이터의 정합성을 확보하고 이상현상 발생을 피하기 위해 정규화를 통해 테이블 분할 → 분할된 테이블로부터 조건에 맞는 정보 조회하기 위해 테이블 간 논리적인 관계 필요하고 그런 관계성을 통해 데이터 출력하는 것
    - 조인 시 칼럼명 앞에 테이블명(테이블 ALIAS) 붙이는 것 권장. ALIAS 사용한다면 WHERE절과 SELECT절에도 원래 테이블명 말고 ALIAS 사용해야.
    - 조인 조건은 (대상 테이블의 개수-1)개 이상 필요
        
        
        | EQUI JOIN (등가조인) | - 두 개의 테이블 간에 칼럼 값들이 서로 정확하게 일치하는 경우에 사용 (PK ↔ FK 관계 기반)
        -WHERE 절에 기술 (”=” 연산자 사용) |
        | --- | --- |
        |  | SELECT T1.COL, T2.COL
        FROM T1, T2
        WHERE T1.COL1 = T2.COL2;
        또는
        SELECT T1.COL, T2.COL
        FROM T1 INNER JOIN T2
             ON T1.COL1 = T2.COL2; |
        | Non-EQUI JOIN (비등가조인) | - 두 개 테이블 간 논리적인 연관 관계 있으나 칼럼 값들이 서로 일치하지 않는 경우 (WHERE절에 비교 연산자 사용)
        - 모델에 따라 Non EQUI JOIN이 불가능한 경우도 존재 |
        | OUTER JOIN | - 조인 조건을 만족하지 않는 행들도 함께 반환
        - 기준이 되는 테이블의 정보는 모두 가져옴
        (ANSI 방식이 아닌 Oracle은 기준 테이블이 아닌 테이블 옆에 (+) 표시) |

## 제2장 SQL 활용

- **표준조인 (FROM절의 조인 형태)**
    
    INNER JOIN, NATURAL JOIN, USING 조건절, ON 조건절, CROSS JOIN, OUTER JOIN
    
    ON 조건절을 통해 JOIN 조건과 데이터 제한 조건 분리해 기술하는 것이 가장 큰 특징!!!
    
    | INNER JOIN | - 조인 조건 만족하는 행만 반환
    - USING, ON 조건절 필수 사용
    SELECT T1.COL, T2.COL
    FROM T1 [INNER] JOIN T2
         ON T1.COL1 = T2.COL2;
    - JOIN 기준 칼럼 - 별개의 칼럼으로 표시 |
    | --- | --- |
    | NATURAL JOIN | - 두 테이블 간 동일한 이름 갖는 모든 칼럼들에 대해 EQUI JOIN 수행
    - USING, ON, WHERE에서 조인 조건 정의할 수 없음
    - JOIN에 사용된 칼럼들은 같은 데이터 유형이어야 하고 ALIAS/테이블명 같은 접두사 불가
    - JOIN이 되는 테이블의 도메인과 칼럼명 등이 동일해야 함. 동일한 칼럼명이더라도 다른 용도의 데이터 저장하는 경우 존재하기 때문에.
    - 별도의 칼럼 순서 지정하지 않으면 NATURAL JOIN의 기준이 되는 칼럼들이 먼저 출력됨
    - JOIN 기준 칼럼 - 하나의 칼럼으로 처리 |
    | USING 조건절 | - 같은 이름을 가진 칼럼들 중에서 원하는 칼럼에 대해서만 선택적으로 EQUI JOIN할 수 있음
    - JOIN에 사용된 칼럼을 하나로 처리
    - 칼럼 순서 지정하지 않으면 기준 되는 칼럼들이 먼저 출력됨
    - JOIN 칼럼에 대해서는 ALIAS와 같은 접두사 붙일 수 없음 |
    | ON 조건절 | - 칼럼명이 다르더라도 조인 조건 사용 가능
    - 이름이 같은 칼럼들에 대해 반드시 ALIAS나 테이블명과 같은 접두사 명확하게 지정해주어야 함
    - JOIN 서술부(ON 조건절)과 비JOIN 서술부(WHERE 조건절) 분리하여 이해가 쉬움
    - WHERE절과 혼용 가능. <검색 조건 목적>인 경우 WHERE 절 사용 권장 |
    | CROSS JOIN | - 테이블 간 조인 조건 없는 경우 생길 수 있는 모든 데이터의 조합
    - CARTESIAN PRODUCT |
    | OUTER JOIN | - 조인 조건에서 동일한 값이 없는 행도 반환할 때 사용할 수 있음
    - USING 조건절이나 ON 조건절 필수적으로 사용해야
    - LEFT [OUTER] JOIN (왼쪽 테이블 기준 (왼쪽 결과집합은 다 나옴)), RIGHT [OUTER] JOIN (오른쪽 테이블 기준)
    - FULL [OUTER] JOIN (두 개 테이블 모두 기준)
    >> LEFT OUTER JOIN과 RIGHT OUTER JOIN의 합집합(UNION)으로써 중복되는 데이터는 삭제함
    >> ANSI 방식으로만 존재 |
    - (순수관계연산자: SELECT연산- WHERE 절로 구현, PROJECT연산- SELECT 절로 구현, NATURAL JOIN- 다양한 JOIN 기능으로 구현)
    - 최소 조인 조건 개수 = 조인 테이블 개수 -1
- **집합 연산자**
    
    **UNION** (중복X), **UNION ALL** (중복O)
    
    >> 둘 다 정렬 필요할 경우에는 명시적으로 ORDER BY 절 사용. ORDER BY 절에 기재하는 칼럼에는 ALIAS 사용불가
    
    **INTERSECT, MINUS**(SQL Server의 경우 EXCEPT 연산자 사용)
    
    | 조인 | 집합연산자 |
    | --- | --- |
    | 조인 조건 사용해 여러 테이블의 행과 행 서로 연결 | 여러 개의 결과 집합 간의 연산을 통해 결합 |
    |  | 서로 다른 테이블에서 유사한 형태의 결과 반환하는 것을 하나의 결과로 합치고자 할 때,
    동일 테이블에서 서로 다른 질의를 수행해 결과 합치고자 할 때 사용 |
    |  | - SELECT 절의 칼럼 수 동일하고
    - SELECT 절의 동일 위치에 존재하는 칼럼의 데이터 타입이 동일해야 함 |
    - ORDER BY 절은 집합 연산을 적용한 최종 결과에 대해 정렬 수행하므로 가장 마지막에 한 번만 기술
    - UNION ALL 연산자는 각각의 질의 결과를 단순히 결합해 줄 뿐 중복된 건을 결과에서 제외하지 않음
    - INTERSECT 연산자는 EXISTS 또는 IN 서브쿼리로 변경 가능
    - MINUS 연산자는 NOT EXISTS 또는 NOT IN 서브쿼리로 변경 가능
    - MINUS 연산하는 과정에서 중복된 행 제거됨 (Ex. A UNION ALL A MINUS B = AA가 아닌 A)
    - 결과 표시할 때 첫번째 SQL문에서 사용된 ALIAS가 적용됨
    - 그룹 함수 사용 가능
- **계층형 질의와 셀프조인**
    
    [계층형 질의]
    
    - 동일 테이블에 계층적으로 상위와 하위 데이터 포함된 경우, 순환관계 데이터 모델
    - `SELECT ,, FROM 테이블 WHERE condition AND condition..`
        
        `**START WITH** condition AND condition…`: 계층 구조 전개의 시작 위치 지정 (루트 데이터 지정)
        
        `**CONNECT BY**[PRIOR] [NO CYCLE] condition AND condition..`: 다음에 전개될 자식 데이터 지정 (조인)
        
        **PRIOR**: CONNECT BY 절에 사용, 현재 읽은 칼럼 지정
        
        >> PRIOR 자식(PK) = 부모(FK): 직전 행의 자식데이터가 현재 행의 부모데이터. 부모 → 자식 방향으로 전개하는 순방향 전개
        
        >> PRIOR 부모(FK) = 자식(PK): 직전 행의 부모데이터가 현재 행의 자식데이터. 자식 → 부모 방향으로 전개하는 역방향 전개
        
        **NO CYCLE**: 사이클 발생한 이후의 데이터 전개하지 않음
        
        `[ORDER SIBLINGS BY column, column, .. ];`: 동일 level에서 정렬 수행
        
    - 계층형 질의 사용할 때 제공하는 가상 칼럼 (Pseudo Column)
        
        
        | LEVEL | 루트 데이터 =1, 리프 데이터까지 1씩 증가 |
        | --- | --- |
        | CONNECT_BY_ISLEAF | 전개 과정에서 해당 데이터가 리프 데이터라면 1, 아니면 0 |
        | CONNECT_BY_ISCYCLE | 전개 과정에서 자식을 갖는데 해당 데이터가 조상으로 존재하면 1, 아니면 0 |
    - 함수:
        - SYS_CONNECT_BY_PATH(칼럼, 경로분리자): 루트 데이터부터 현재 전개할 데이터까지의 경로 표시
        - CONNECT_BY_ROOT 칼럼: 현재 전개할 데이터의 루트 데이터 표시. 단항.
    
    [셀프조인]
    
    - 동일 테이블 사이의 조인
    - FROM 절에 동일 테이블 두 번 이상 나타남
    - **반드시** 테이블별칭 사용해야
- **서브쿼리**
    - SQL문 안에 포함되어 있는 또 다른 SQL문
    - **서브쿼리는 메인쿼리의 칼럼을 모두 사용할 수 있지만 메인쿼리는 서브쿼리의 칼럼을 사용할 수 없음.** 질의 결과에 서브쿼리 칼럼 표시해야 한다면 조인 방식으로 변환하거나 함수, 스칼라 서브쿼리 등 사용
        - 비연관 서브쿼리: 서브 쿼리가 메인 쿼리 칼럼을 갖고 있지 않는 형태
        - **연관 서브쿼리**: 서브 쿼리가 메인 쿼리 칼럼 갖고 있는 형태
    - 서브쿼리는 괄호로 감싸서 기술, 중첩 서브 쿼리 및 스칼라 서브쿼리에는 ORDER BY 절 사용 X
    
    | 단일행 서브쿼리 | - 실행결과가 항상 1건 이하
    - 단일행 비교연산자 (=, >, <, >=, =<. <>)와 사용 |
    | --- | --- |
    | 다중행 서브쿼리 | - 실행결과가 여러 건
    - IN, ALL, ANY/SOME(SQL Server), EXISTS와 사용
    - EXISTS의 경우 조건 만족하는 2건만 찾으면 추가적인 검색 진행하지 않음 |
    | 다중 칼럼 서브쿼리 | - 서브쿼리의 결과로 여러 개의 칼럼이 반환돼 메인 쿼리의 조건과 동시에 비교 |
    
    [그 밖의 위치에서 사용하는 서브쿼리]
    
    | SELECT절 | 스칼라 서브쿼리 (Scalar Subquery)
    - 한 행, 한 칼럼만을 반환
    - 단일행 서브쿼리임
    - 칼럼이 올 수 있는 곳에서 사용 |
    | --- | --- |
    | FROM절 | 인라인 뷰 (Inline View)
    - 서브쿼리의 결과를 마치 테이블처럼 사용 가능
    - SQL 문 실행될 때만 임시적으로 생성되는 동적인 뷰 (DB에 저장 안됨)
    - 테이블이 올 수 있는 곳에서 사용
    - ORDER BY절 사용 가능 (TOP-N 쿼리.. see below) |
    | WHERE절 |  |
    | HAVING절 |  |
    | UPDATE 문의 SET절 |  |
    | INSERT 문의 VALUES절 |  |
    - **Top N 쿼리**
        
        
        | ROWNUM | - pseudo column(의사열): 집합의 각 행에 대해 임시로 부여되는 일련번호
        - 테이블이나 집합에서 원하는 만큼의 행만 가져오고 싶을 때 WHERE절에서 행의 개수 제한하는 목적으로 사용
        - oracle의 경우 정렬이 완료된 후 데이터의 일부가 출력되는 것이 아니라 데이터의 일부가 먼저 추출된 후 데이터에 대한 정렬 작업이 일어남. 그래서 정렬 후 원하는 데이터 얻기 위해서는 인라인 뷰에서 먼저 데이터 정렬한 후 메인쿼리에서 ROWNUM 조건 사용해야 |
        | --- | --- |
        | TOP 절 | - TOP (expression) [PERCENT] [WITH TIES]
        >> expression: 반환할 행 수 지정하는 숫자
        >> WITH TIES: ORDER BY절이 지정된 경우에만 사용 가능, TOP N(PERCENT)의 마지막 행과 같은 값이 있는 경우 동일 수치 데이터 추가로 추출 |
        | ROW LIMITING 절 | - ORDER BY 절 다음에 기술, ORDER BY 절과 수행
        - [OFFSET offset {ROW | ROWS}]
           [ FETCH {FIRST | NEXT} [{rowcount | percent PERCENT}] {ROW | ROWS} {ONLY | WITH TIES}]
        >> OFFSET offset: 건너뛸 행 개수 지정 (OFFSET만 기술하면 건너뛴 행 이후 전체 행 반환)
        >> FETCH: 반환할 행의 개수나 백분율 지정
        >> ONLY: 지정된 행의 개수나 백분율만큼 행 반환
        >> WITH TIES: 마지막 행에 대한 동순위 포함해서 반환 |
    
    [뷰(VIEW)]
    
    - 실제 데이터를 가지고 있지 않음. 뷰 정의만 가지고 있음
    - 장점: **독립성** (테이블 구조 변경되어도 뷰는 그대로), **편리성** (복잡한 질의 뷰로 생성함으로써 관련 질의 단순하게 작성 가능), **보안성** (사용자에게 정보 감출 수 있음)
    - 이미 존재하는 뷰를 참조해서도 생성 가능
    - `CREATE VIEW VIEW명 AS SELECT…` 로 생성 가능
    - `DROP VIEW`로 제거
- **그룹 함수**
    
    
    | ROLLUP | 소그룹간 소계 계산
    - grouping columns의 수가 N개일 때 N+1 Level의 subtotal 생성
    - ROLLUP의 인수는 계층 구조이므로 인수 순서가 바뀌면 수행 결과도 바뀜. 주의
    - 계층 간 정렬은 하지만 계층 내 집계는 별도의 정렬 지원하지 않음. 별도의 ORDER BY 절 사용해야 |
    | --- | --- |
    | CUBE | GROUP BY 항목 간 다차원적인 소계 계산
    - grouping columns의 수가 N개일 때 2의 N승 Level의 subtotal 생성
    - 인수 간 평등한 관계. 따라서 인수 순서 바뀌어도 행간에 정렬 순서는 바뀔 수 있어도 데이터가 바뀌진 않음 |
    | GROUPING SETS | 특정 항목에 대한 소계 계산
    - 표시된 인수들에 대한 개별 집계
    - 인수들 간 평등한 관계. 인수 순서 바뀌어도 같은 결과
    - 묶은 집합 별로 집계 구함
    - 인수를 어떻게 지정하느냐에 따라 CUBE와 결과 같을 수도, 다를 수도  |
    
    >> 정렬 필요한 경우 ORDER BY 절에 정렬 칼럼 명시해야
    
    >> GROUPING  함수: 소계가 계산된 결과에는 GROUPING(EXPR)=1 아니라면 0 표시 
    
    (CASE/DECODE 이용해 소계 나타내는 필드에 원하는 문자열 지정 가능)
    
- **윈도우 함수 (=분석함수=순위함수)**
    
    절차형 프로그램 작성하거나 INLINE VIEW 통해 복잡한 SQL문 작성해야 하던 것을 부분적이나마 행과 행간의 관계 쉽게 정의하기 위해 만든 함수
    
    - 중첩해서 사용하지는 못함
    - 서브쿼리에서는 사용 가능
    - 결과에 대해 함수처리하는 것이므로 결과 건수가 줄어들지는 않음
        
        `SELECT WINDOW_FUNCTION (ARGUMENTS) **OVER** ([PARTITION BY 칼럼] [ORDER BY 절] [WINDOWING 절]) FROM 테이블명;`
        
        - ARGUMENTS (인수): 0-N 개
        - PARTITION BY 절: 전체 집합을 기준에 의해 소그룹으로 나눌 수 있음
        - ORDER BY 절: 어떤 항목에 대해 순위를 지정할 지 기술
        - **WINDOWING 절**: 함수의 대상이 되는 행 기준의 범위 지정
            - ROWS: 물리적인 결과 행 수, RANGE: 논리적인 값에 의한 범위
            - [BETWEEN 사용 타입]
                
                ROWS | RANGE BETWEEN UNBOUNDED PRECEDING | CURRENT ROW | VALUE_EXPR PRECEDING/FOLLOWING  AND UNBOUNDED FOLLOWING | CURRENT ROW | VALUE_EXPR PRECEDING/FOLLOWING
                
                - 예) ROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING: 현재 행 기준으로 파티션 내에서 앞의 한 건, 현재 행, 뒤의 한 건을 범위로 지정
                - 예) RANGE BETWEEN 50 PRECEDING AND 150 FOLLOWING: -50에서 +150의 범위 내
            - [BETWEEN 미사용 타입]
                
                ROWS | RANGE UNBOUNDED | CURRENT ROW | VALUE_EXPR PRECEDING
                
                - 예) RANGE UNBOUNDED PRECEDING: 현재 행 기준으로 파티션 내 첫 번째 행까지의 범위 지정
            
            | 그룹 내 순위 관련 | RANK | - PARTITION 내에서 순위 구할 수도 있고 전체 데이터에 대한 순위 구할 수도 있음
            - 동일한 값에 대해서는 동일한 순위 부여 (1→1→1→4→…) |
            | --- | --- | --- |
            |  | DENSE_RANK | - 동일한 순위를 하나의 건수로 취급 (1→1→1→2→…) |
            |  | ROW_NUMBER | - 동일한 값이라도 고유한 순위 부여
            - 동일 값에 대한 순서까지 관리하고 싶으면 ORDER BY 절 함께 사용 |
            | 그룹 내 집계 관련 | SUM, MAX, MIN, AVG, COUNT |  |
            | 그룹 내 행 관련 | FIRST_VALUE | - 파티션 별 윈도우에서 가장 먼저 나온 값
            - RANGE UNBOUNDED PRECEDING
            - 공동 등수 인정하지 않고 처음 나온 행만 처리 |
            |  | LAST_VALUE | - 파티션 별 윈도우에서 가장 나중에 나온 값
            - ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING
            - 공동 등수 인정하지 않고 가장 나중에 나온 행만을 처리 |
            |  | LAG | - 파티션 별 윈도우에서 이전 몇 번째 행의 값 가져오기
            - 3개의 인수 가능: (값 가져올 칼럼, 몇 번째 앞의 행 가져올지, 가져올 데이터 없을 때) |
            |  | LEAD | - 파티션 별 윈도우에서 이후 몇 번째 행의 값 가져오기 |
            | 그룹 내 비율 관련 | CUME_DIST | - 파티션 별 윈도우의 전체 건수에서 현재 행보다 작거나 같은 건수에 대한 누적백분율 구함
            - 값이 같다면 같은 ORDER로 취급해서 같은 누적백분율 표시
            - 동일 순서면 뒤 행의 함수 결과값을 기준으로 (다른 WINDOW 함수의 경우 앞행의 함수 결과 값) |
            |  | PERCENT_RANK | - 파티션 내에서 가장 먼저 나오는 것을 0, 나중에 나오는 것을 1로 해서 값이 아닌 해의 순서별 백분율 구함 |
            |  | NTILE | - 전체 건수를 ARGUMENT 값으로 N 등분 |
            |  | RATIO_TO_REPORT | - 파티션 내 전체 SUM(칼럼) 값에 대한 행별 칼럼 값의 백분율을 소수점으로
            - 개별 RATIO 합 구하면 1 됨 |
    
- **PIVOT, UNPIVOT**
    
    [PIVOT]
    
    행 → 열
    
    `**PIVOT** (aggregate function(expr) **FOR** 피벗대상 열 **IN** (피벗할 열 값);`
    
    [UNPIVOT]
    
    열 → 행
    
    `**UNPIVOT** unpivot한 값 들어갈 열 **FOR** unpivot된 값을 설명할 값이 들어갈 열 **IN** unpivot할 열과 설명할 값의 리터럴 값 지정(행으로 전환될 열);`
    
- **정규 표현식**
    
    문자열의 규칙 표현하는 검색 패턴
    
    주로 문자열 검색과 치환에 사용
    
    [POSIX 연산자]
    
    | . | 모든 문자와 일치 |
    | --- | --- |
    | | | or |
    | \ | 다음 문자를 일반 문자로 취급 |
    | ^ | 문자열의 시작 |
    | $ | 문자열의 끝 |
    | ? | 0회 또는 1회 일치 |
    | * | 0회 이상 일치 |
    | + | 1회 이상 일치 |
    | {m} | m회 일치 |
    | {m,} | 최소 m회 일치 |
    | {,m} | 최대 m회 일치 |
    | {m,n} | 최소 m회 최대 n회 일치 |
    | (expr) | 괄호 안의 표현식을 하나의 단위로 취급 |
    | [char…] | 문자 리스트 중 한 문자와 일치 |
    | [^char…] | 문자 리스트에 포함되지 않은 한 문자와 일치 |
    
    REGEXP_LIKE: 패턴과 일치하면 TRUE 일치하지 않으면 FALSE 반환
    
    REGEXP_REPLACE: 패턴 일치한 부분 변경
    
    REGEXP_SUBSTR: 패턴 일치한 부분 반환
    
    REGEXP_INSTR: 일치한 패턴의 시작 위치를 정수로 반환
    
    REGEXP_COUNT: 일치한 패턴의 횟수 반환
    
- **DCL**
    
    유저 생성하고 권한 제어
    
    [**유저 생성**과 **시스템 권한** 부여]
    
    모든 DDL 문장(CREATE, ALTER, DROP, RENAME 등)은 그에 해당하는 적절한 권한이 있어야만 문장 실행 가능 ⇒ **시스템 권한**
    
    - `GRANT CREATE USER`
    - `GRANT CREATE SESSION`
    - `GRANT CREATE TABLE`
    
    [**OBJECT(객체)에 대한 권한**]
    
    - 다른 유저가 소유한 객체에 접근하려면 객체 앞에 객체 수유한 유저의 이름 붙여야
    - SELECT, INSERT, DELETE, UPDATE 등의 권한 따로 관리
    - SELECT: `GRANT SELECT ON 테이블명 TO 유저;`
    
    [ROLE을 이용한 권한 부여]
    
    - 유저가 생성될 때마다 각각의 권한들을 유저에게 부여하는 작업 수행해야 = 번거로움
    - ROLE을 생성하고 ROLE에 각종 권한들 부여한 후 ROLE을 다른 ROLE이나 유저에게 부여
        - 빠르고 안전하게 유저 관리 가능
    - ROLE을 통해 시스템 권한과 오브젝트 권한 모두 부여 가능
    - `GRANT ROLE 롤명;`
        
        `GRANT CREATE SESSION, CREATE TABLE TO 롤명;`
        
        `GRANT 롤명 TO 유저;`
        
    - Oracle에서 기본적으로 제공하는  ROLE
        
        
        | CONNECT (로그인 권한) | RESOURCE (오브젝트 생성 권한) |
        | --- | --- |
        | CREATE SESSION | CREATE CLUSTER |
        |  | CREATE INDEXTYPE |
        |  | CREATE OPERATOR |
        |  | CREATE SEQUENCE |
        |  | CREATE PROCEDURE |
        |  | CREATE TABLE |
        |  | CREATE TRIGGER |
        |  | CREATE TYPE |
    
    >> `DROP USER`: 유저 삭제 (`CASCADE`옵션 주변 해당 유저가 생성한 오브젝트 먼저 삭제한 후 유저 삭제)
    
    >> REVOKE 문: 사용자로부터 부여된 권한 회수
    
- **절차형 SQL (=PL/SQL: Procedural Language for SQL)**
    - SQL문의 연속적인 실행이나 조건에 따른 분기처리 이용하여 특정 기능 수행하는 저장 모듈 생성 가능
    - Block 구조로 되어 있으며 SQL문, IF문, LOOP문 등 존재
    - 각 기능별로 모듈화 가능
    - DBMS 정의 에러나 사용자 정의 에러를 정의하여 사용할 수 있음
    - 여러 SQL 문장을 Block로 묶고 한 번에 Block 전부를 서버로 보내기 때문에 통신량 줄일 수 있음
    - Oracle에 내장되어 있으므로 호환성 좋음
    
    [PL/SQL Block 구조]
    
    | DECLARE (선언부) | (필수)
    - BEGIN-END 에서 사용할 변수나 인수에 대한 정의 및 데이터형 선언 |
    | --- | --- |
    | BEGIN (실행부) | (필수)
    - 처리하고자 하는 SQL문과 필요한 로직(비교문, 제어문 등) 정의 |
    | EXCEPTION (예외 처리부) | (선택)
    - BEGIN-END에서 실행되는 SQL문제 발생된 에러 처리 |
    | END | (필수)
    - BEGIN부터 시작한 SQL문과 필요한 로직의 종료 선언 (=PL/SQL의 종료 선언) |
    - 프로시저
        
        CREATE PROCEDURE
        
        EXECUTE/EXEC 명령어로 실행
        
        프로시저 내부에서 COMMIT, ROLLBACK 실행 가능
        
    - **사용자 정의 함수**
        
        IF, LOOP 등의 로직과 함께 데이터베이스에 저장해놓은 명령문의 집합
        
        프로시저와 달리 반환값 되돌려줘야 하고 SELECT문과 결합하여 호출 가능
        
    - **트리거**
        
        CREATE TRIGGER
        
        테이블에 **데이터 입력하면(DML)** 자동으로 UPDATE 혹은 INSERT 시켜주는 것. DB **자동 수행**
        
        - (프로시저는 프로시저 내부에서 커밋 혹은 롤백 수행하지만) 트리거는 트리거가 발생된 원인이 된 SQL문이 커밋 혹은 롤백되는지에 따라 트리거의 실행 결과가 데이터베이스에 최종 적용될지 말지 결정됨
            - = 내부에서 COMMIT, ROLLBACK 실행 안됨
    
    T-SQL… SQL Server 제어하는 언어
    

## 제3장 SQL 최적화 기본원리

- **옵티마이저와 실행계획**
    - 옵티마이저(Optimizer): 사용자가 질의한 SQL문에 대해 최적의 실행방법을 결정하는 역할 수행 (=실행계획(Execution Plan))
    
    | 규칙기반 | 비용기반 |
    | --- | --- |
    | - 별로 지원 안 함 | - 대부분의 관계형 데이터베이스에서 지원 |
    | - 규칙(우선순위) 가지고 실행계획 생성
    > 1순위. Single row by rowid: ROWID 통해서 하나의 행 엑세스
    > 4순위. Single row by unique or primary key: 유일 인덱스 통해서 하나의 행 엑세스
    > 8순위. Composite index:  복합 인데스에 대해서 인덱스 구성 칼럼의 개수가 더 많고 해당 인덱스의 모든 구성 칼럼에 대해 ‘=’로 값이 주어질 수록 우선순위가 높음
    .
    .
    .
    > 15순위. Full table scan
    - 인덱스 존재한다면 항상 인덱스 사용하는 실행계획 생성
    - 조인 순서: 조인 칼럼 인덱스의 존재 유무가 중요한 판단의 기준….etc | - SQL문 처리하는데 필요한 비용(예상되는 소요시간 또는 자원 사용량)이 가장 적은 실행계획 선택하는 방식
    - 정확한 통계정보 필요. 통계 정보 없는 경우 정확한 비용 예측 불가능해져서 비효율적인 실행계획 생성 가능
    - 인덱스 있어도 인덱스 사용하는 비용이 전체 테이블 스캔 비용보다 크다고 판단되면 전체 테이블 스캔 수행할 수도 |
    - 실행계획 구성 요소:
        - **조인 순서**(Join Order): 조인작업 수행할 때 참조하는 테이블의 순서
        - **조인 기법**(Join Method): NL Join, Hash Join, Sort Merge, Join 등
        - **액세스 기법**(Access Method): 하나의 테이블 액세스할 때 사용할 수 있는 방법 (인텍스 스캔, 전체 테이블 스캔)
        - **최적화 정보**(Optimization Information): Cost, Card, Bytes
        - **연산**(Operation) 등
    - SQL 처리 흐름도
        - SQL의 내부적인 처리 절차 시각적으로 표현한 도표 (실행계획 시각화)
        - 엑세스 건수, 조인 시도 건수, 테이블 액세스 건수, 성공 건수 + 작업한 건수, 처리 결과 건수 등의 일량 함께 표시 가능
- **인덱스 기본**
    
    인덱스 목적: 검색 성능 최적화
    
    - INSERT, UPDATE, DELETE 등과 같은 DML 작업은 오히려 느려질 수 있음
        
        
        | 트리 기반 인덱스 | SQL SERVER 클러스터형 인덱스 |
        | --- | --- |
        | - B-트리 인덱스
        > ‘=’로 검색하는 일치 검색과 ‘>’, ‘BETWEEN’ 등과 같은 연산자로 검색하는 범위(range) 검색에 모두 적합한 구조
        - Branch block, 
        - Leaf block (rowid), 양방향 링크 가지고 있어서 오름차순과 내림 차순 검색 쉽게 할 수 있음
        - Root block
        - 인덱스 데이터는 인덱스를 구성하는 칼럼의 값으로 정렬
        - 인덱스 구성 칼럼은 동일하지만 칼럼의 순서가 다르면 서로 다른 인덱스로 생성 가능
        
        - 비트맵 인덱스(Bitmap Index), 리버스 키 인덱스(Reverse Key Index), 함수기반 인덱스(FBI, Function-Based Index) 등도 존재
         | - 인덱스의 리프 페이지가 곧 데이터 페이지 (테이블 탐색에 필요한 레코드 식별자가 리프 페이지에 없음)
        - 리프 페이지의 모든 데이터(row)는 인덱스 키 칼럼 순으로 물리적으로 정렬되어 저장됨 |
        
        | 전체 테이블 스캔 | 인덱스 스캔 |
        | --- | --- |
        | - 테이블에 존재하는 모든 데이터를 읽어 가면서 조건에 맞으면 결과로서 추출하고 맞지 않으면 버림
        - 테이블에 존재하는 모든 블록의 데이터 읽음 = 비효율적인 검색 | - 인덱스를 구성하는 칼럼의 값을 기반으로 데이터를 추출하는 기법
        - 인덱스의 리프 블록: 인덱스 구성하는 칼럼과 레코드 식별자로 구성
        
        - 인덱스 유일 스캔: 유일 인덱스 사용하여 단 하나의 데이터 추출 (중복 x), 모두 ‘=’로 값이 주어진 경우에만 가능
        - 인덱스 범위 스캔: 인덱스 이용하여 한 건 이상의 데이터 추출하는 방식
        - 인덱스 역순 범위 스캔 |
        | - 선택이유
        1) SQL문에 조건 존재하지 않는 경우
        2) SQL문의 주어진 조건에 사용 가능한 인덱스가 존재하지 않는 경우
        3) 옵티마이저의 취사 선택
        4) 그 밖의 경우 (병렬처리 방식으로 처리, 전체 테이블 스캔 방식의 힌트 사용) | - 인덱스에 존재하는 레코드 식별자 이용해서 검색하는 데이터의 정확한 위치 알고 데이터 읽음 (불필요하게 다른 블록 더 읽을 필요 x) |
    
- **조인 수행 원리**
    
    2개 이상 테이블 조인할 때 조인 단계별로 다른 조인 기법 사용할 수 있음
    
    | NL Join | Sort Merge Join | Hash Join |
    | --- | --- | --- |
    | Nested Loop Join |  |  |
    | 결과 행의 수가 적은 테이블을 조인 순서상 선행 테이블로 선택하는 것이 전체 일량을 줄일 수 있음. 랜덤 방식으로 데이터를 액세스 하기 때문에 처리 범위가 좁은 것이 유리 | - 조인 칼럼을 기준으로 데이터 정렬하여 조인 수행
    - 스캔 방식으로 데이터 읽음
    - 넓은 범위의 데이터 처리할 때 이용
    - 데이터가 너무 많은 경우에는 성능 떨어질 수 있음
    - Hash와 달리 동등 조인 뿐만 아니라 비동등 조인에 대해서도 조인 작업이 가능하다는 장점 | - 대량의 조인 작업에서 정렬 작업 필요로 하면 Soft Merge보다 Hash가 성능상 유리
    - Hashing 기법 이용해서 조인 수행
    - 조인 수행할 테이블의 조인 칼럼 기준으로 서로 동일한 해쉬 값 갖는 것들 사이에서 실제 값이 같은지 비교하면서 조인 수행
    ⇒ NL Join의 랜덤 액세스 문제점과 Sort Merge Join의 정렬 작업 부담 문제점 해결 위한 대안으로 등장 |
    | 1) 선행 테이블에서 주어진 조건 만족하는 행 찾음
    2) 선행 테이블의 조인 키 값 가지고 후행 테이블에서 조인 수행
    3) 선행 테이블의 조건 만족하는 모든 행에 대해 1번 작업 반복 수행 |  |  |